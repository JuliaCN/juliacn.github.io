<!doctype html> <html lang=en > <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name=author  content="Julia 中文社区的全体成员"> <meta name=description  content="Julia 中文社区的主页。Julia 中文社区是一个社区驱动、致力于 Julia 编程语言中文支持的开源组织。"> <meta name=keywords  content="Julia 中文, Julia 语言, Julia 中文社区, Julia 编程语言"> <meta name=robots  content="index, follow"> <meta property="og:title" content="Julia 中文社区"> <meta property="og:image" content="/assets/infra/logo_cn.png"> <meta property="og:description" content="社区驱动，致力于 Julia 编程语言中文支持的开源组织"> <link rel=stylesheet  href="/libs/bootstrap/bootstrap.min.css"> <link rel=stylesheet  href="/css/app.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/fonts.css"> <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel=stylesheet > <link href="https://libs.cdnjs.net/font-awesome/4.7.0/css/font-awesome.min.css" rel=stylesheet > <script async defer src="/libs/buttons.js"></script> <!-- --> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-28835595-9', 'auto'); ga('send', 'pageview'); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <link rel=icon  href="/assets/infra/julia.ico"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <title>Technical preview: Native GPU programming with CUDAnative.jl</title> <style> .container ul li p {margin-bottom: 0;} </style> <style> .main { font-family: Georgia; } .main pre { margin-left: auto; margin-right: auto; } .main { width: 100%; font-size: 100%; } .main code { font-size: 90%; } .main pre code { font-size: 90%; } @media (min-width: 940px) { .main { width: 800px; } .container.blog-title { width: 800px;} } </style> <div class="container py-3 py-lg-0"> <nav class="navbar navbar-expand-lg navbar-light bg-light" id=main-menu > <a class=navbar-brand  href="/"> <img src="/assets/infra/logo_cn.png" alt="JuliaLang Logo"> </a> <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mx-auto"> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/downloads/">下载</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://docs.juliacn.com/">文档</a> <li class="nav-item active flex-md-fill text-md-center"> <a class=nav-link  href="https://julialang.org/blog/">博客</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://julialang.org/community/">社区</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://julialang.org/learning/">学习</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://julialang.org/research/">研究</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://julialang.org/jsoc/">JSoC</a> </ul> <span class=navbar-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">赞助 JuliaLang 组织</a> </span> </div> </nav> </div> <br><br> <div class="container blog-title"> <h1>Technical preview: Native GPU programming with CUDAnative.jl <a type="application/rss+xml" href="https://julialang.org/feed.xml"> <i class="fa fa-rss-square rss-icon"></i> </a> </h1> <h3> <span style="font-weight: lighter;"> 14 March 2017 </span> | <span style="font-weight: bold;"></span> <span style="font-weight: bold;"><a href="https://github.com/maleadt">Tim Besard</a> </span> </h3> </div> <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/blog/2017/03/cudanative.md" title="Edit this page on GitHub" class=edit-float > </a> <div class="container main"><p>After 2 years of slow but steady development, we would like to announce the first preview release of native GPU programming capabilities for Julia. You can now write your CUDA kernels in Julia, albeit with some restrictions, making it possible to use Julia&#39;s high-level language features to write high-performance GPU code.</p> <p>The programming support we&#39;re demonstrating here today consists of the low-level building blocks, sitting at the same abstraction level of CUDA C. You should be interested if you know &#40;or want to learn&#41; how to program a parallel accelerator like a GPU, while dealing with tricky performance characteristics and communication semantics.</p> <p>You can easily add GPU support to your Julia installation &#40;see below for detailed instructions&#41; by installing <a href="https://github.com/JuliaGPU/CUDAnative.jl">CUDAnative.jl</a>. This package is built on top of experimental interfaces to the Julia compiler, and the purpose-built <a href="https://github.com/maleadt/LLVM.jl">LLVM.jl</a> and <a href="https://github.com/JuliaGPU/CUDAdrv.jl">CUDAdrv.jl</a> packages to compile and execute code. All this functionality is brand-new and thoroughly untested, so we need your help and feedback in order to improve and finalize the interfaces before Julia 1.0.</p> <div class=franklin-toc ><ol><li><a href="#how_to_get_started">How to get started</a><li><a href="#hello_world_vector_addition">&quot;Hello World&quot; Vector addition</a><ol><li><a href="#how_does_it_work">How does it work?</a><li><a href="#what_is_missing">What is missing?</a></ol><li><a href="#another_example_parallel_reduction">Another example: parallel reduction</a><li><a href="#try_it_out">Try it out&#33;</a><ol><li><a href="#i_want_to_help">I want to help</a></ol><li><a href="#thanks">Thanks</a></ol></div> <h2 id=how_to_get_started ><a href="#how_to_get_started" class=header-anchor >How to get started</a></h2> <p>CUDAnative.jl is tightly integrated with the Julia compiler and the underlying LLVM framework, which complicates version and platform compatibility. For this preview we only support Julia 0.6 built from source, on Linux or macOS. Luckily, installing Julia from source is well documented in the <a href="https://github.com/JuliaLang/julia/blob/master/README.md#source-download-and-compilation">main repository&#39;s README</a>. Most of the time it boils down to the following commands:</p> <pre><code class="bash hljs">$ git <span class=hljs-built_in >clone</span> https://github.com/JuliaLang/julia.git
$ <span class=hljs-built_in >cd</span> julia
$ git checkout v0.6.0-pre.alpha  <span class=hljs-comment ># or any later tag</span>
$ make                           <span class=hljs-comment ># add -jN for N parallel jobs</span>
$ ./julia</code></pre> <p>From the Julia REPL, installing CUDAnative.jl and its dependencies is just a matter of using the package manager. Do note that you need to be using the NVIDIA binary driver, and have the CUDA toolkit installed.</p> <pre><code class="julia hljs">Pkg.add(<span class=hljs-string >&quot;CUDAnative&quot;</span>)

<span class=hljs-comment ># Optional: test the package</span>
Pkg.test(<span class=hljs-string >&quot;CUDAnative&quot;</span>)</code></pre> <p>At this point, you can start writing kernels and execute them on the GPU using CUDAnative&#39;s <code>@cuda</code>&#33; Be sure to check out the <a href="https://github.com/JuliaGPU/CUDAnative.jl/tree/master/examples">examples</a>, or continue reading for a more textual introduction.</p> <h2 id=hello_world_vector_addition ><a href="#hello_world_vector_addition" class=header-anchor >&quot;Hello World&quot; Vector addition</a></h2> <p>A typical small demo of GPU programming capabilities &#40;think of it as the <em>GPU Hello World</em>&#41; is to perform a vector addition. The snippet below does exactly that using Julia and CUDAnative.jl:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> CUDAdrv, CUDAnative

<span class=hljs-keyword >function</span> kernel_vadd(a, b, c)
    <span class=hljs-comment ># from CUDAnative: (implicit) CuDeviceArray type,</span>
    <span class=hljs-comment >#                  and thread/block intrinsics</span>
    i = (blockIdx().x-<span class=hljs-number >1</span>) * blockDim().x + threadIdx().x
    c[i] = a[i] + b[i]

    <span class=hljs-keyword >return</span> <span class=hljs-literal >nothing</span>
<span class=hljs-keyword >end</span>

dev = CuDevice(<span class=hljs-number >0</span>)
ctx = CuContext(dev)

<span class=hljs-comment ># generate some data</span>
len = <span class=hljs-number >512</span>
a = rand(<span class=hljs-built_in >Int</span>, len)
b = rand(<span class=hljs-built_in >Int</span>, len)

<span class=hljs-comment ># allocate &amp; upload on the GPU</span>
d_a = CuArray(a)
d_b = CuArray(b)
d_c = similar(d_a)

<span class=hljs-comment ># execute and fetch results</span>
<span class=hljs-meta >@cuda</span> (<span class=hljs-number >1</span>,len) kernel_vadd(d_a, d_b, d_c)    <span class=hljs-comment ># from CUDAnative.jl</span>
c = <span class=hljs-built_in >Array</span>(d_c)

<span class=hljs-keyword >using</span> Base.Test
<span class=hljs-meta >@test</span> c == a + b

destroy(ctx)</code></pre> <h3 id=how_does_it_work ><a href="#how_does_it_work" class=header-anchor >How does it work?</a></h3> <p>Most of this example does not rely on CUDAnative.jl, but uses functionality from CUDAdrv.jl. This package makes it possible to interact with CUDA hardware through user-friendly wrappers of CUDA&#39;s driver API. For example, it provides an array type <code>CuArray</code>, takes care of memory management, integrates with Julia&#39;s garbage collector, implements <code>@elapsed</code> using GPU events, etc. It is meant to form a strong foundation for all interactions with the CUDA driver, and does not require a bleeding-edge version of Julia. A slightly higher-level alternative is available under <a href="https://github.com/JuliaGPU/CUDArt.jl">CUDArt.jl</a>, building on the CUDA runtime API instead, but hasn&#39;t been integrated with CUDAnative.jl yet.</p> <p>Meanwhile, CUDAnative.jl takes care of all things related to native GPU programming. The most significant part of that is generating GPU code, and essentially consists of three phases:</p> <ol> <li><p><strong>interfacing with Julia</strong>: repurpose the compiler to emit GPU-compatible LLVM IR &#40;no calls to CPU libraries, simplified exceptions, ...&#41;</p> <li><p><strong>interfacing with LLVM</strong> &#40;using LLVM.jl&#41;: optimize the IR, and compile to PTX</p> <li><p><strong>interfacing with CUDA</strong> &#40;using CUDAdrv.jl&#41;: compile PTX to SASS, and upload it to the GPU</p> </ol> <p>All this is hidden behind the call to <code>@cuda</code>, which generates code to compile our kernel upon first use. Every subsequent invocation will re-use that code, convert and upload arguments<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup>, and finally launch the kernel. And much like we&#39;re used to on the CPU, you can introspect this code using runtime reflection:</p> <pre><code class="julia hljs"><span class=hljs-comment ># CUDAnative.jl provides alternatives to the @code_ macros,</span>
<span class=hljs-comment ># looking past @cuda and converting argument types</span>
julia&gt; CUDAnative.<span class=hljs-meta >@code_llvm</span> <span class=hljs-meta >@cuda</span> (<span class=hljs-number >1</span>,len) kernel_vadd(d_a, d_b, d_c)
define void <span class=hljs-meta >@julia_kernel_vadd_68711</span> {
    [LLVM IR]
}

<span class=hljs-comment ># ... but you can also invoke without @cuda</span>
julia&gt; <span class=hljs-meta >@code_ptx</span> kernel_vadd(d_a, d_b, d_c)
.visible .func julia_kernel_vadd_68729(...) {
    [PTX CODE]
}

<span class=hljs-comment ># or manually specify types (this is error prone!)</span>
julia&gt; code_sass(kernel_vadd, (CuDeviceArray{<span class=hljs-built_in >Float32</span>,<span class=hljs-number >2</span>},CuDeviceArray{<span class=hljs-built_in >Float32</span>,<span class=hljs-number >2</span>},CuDeviceArray{<span class=hljs-built_in >Float32</span>,<span class=hljs-number >2</span>}))
code <span class=hljs-keyword >for</span> sm_20
        <span class=hljs-built_in >Function</span> : julia_kernel_vadd_68481
[SASS CODE]</code></pre> <sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup> <p>Another important part of CUDAnative.jl are the intrinsics: special functions and macros that provide functionality hard or impossible to express using normal functions. For example, the <code>&#123;thread,block,grid&#125;&#123;Idx,Dim&#125;</code> functions provide access to the size and index of each level of work. Local shared memory can be created using the <code>@cuStaticSharedMem</code> and <code>@cuDynamicSharedMem</code> macros, while <code>@cuprintf</code> can be used to display a formatted string from within a kernel function. Many <a href="https://github.com/JuliaGPU/CUDAnative.jl/blob/0721783db9ac4cc2c2948cbf8cbff4aa5f7c4271/src/device/intrinsics.jl#L499-L807">math functions</a> are also available; these should be used instead of similar functions in the standard library.</p> <h3 id=what_is_missing ><a href="#what_is_missing" class=header-anchor >What is missing?</a></h3> <p>As I&#39;ve already hinted, we don&#39;t support all features of the Julia language yet. For example, it is currently impossible to call any function from the Julia C runtime library &#40;aka. <code>libjulia.so</code>&#41;. This makes dynamic allocations impossible, cripples exceptions, etc. As a result, large parts of the standard library are unavailable for use on the GPU. We will obviously try to improve this in the future, but for now the compiler will error when it encounters unsupported language features:</p> <pre><code class="julia hljs">julia&gt; nope() = println(<span class=hljs-number >42</span>)
nope (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)

julia&gt; <span class=hljs-meta >@cuda</span> (<span class=hljs-number >1</span>,<span class=hljs-number >1</span>) nope()
ERROR: error compiling nope: emit_builtin_call <span class=hljs-keyword >for</span> REPL[<span class=hljs-number >1</span>]:<span class=hljs-number >1</span> requires the runtime language feature, which is disabled</code></pre> <p>Another big gap is documentation. Most of CUDAnative.jl mimics or copies <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/">CUDA C</a>, while CUDAdrv.jl wraps the <a href="https://docs.nvidia.com/cuda/cuda-driver-api/">CUDA driver API</a>. But we haven&#39;t documented what parts of those APIs are covered, or how the abstractions behave, so you&#39;ll need to refer to the examples and tests in the CUDAnative and CUDAdrv repositories.</p> <h2 id=another_example_parallel_reduction ><a href="#another_example_parallel_reduction" class=header-anchor >Another example: parallel reduction</a></h2> <p>For a more complex example, let&#39;s have a look at a <a href="https://github.com/JuliaGPU/CUDAnative.jl/blob/0721783db9ac4cc2c2948cbf8cbff4aa5f7c4271/examples/reduce/reduce.cu">parallel reduction</a> for <a href="https://devblogs.nvidia.com/parallelforall/faster-parallel-reductions-kepler/">Kepler-generation GPUs</a>. This is a typical well-optimized GPU implementation, using fast communication primitives at each level of execution. For example, threads within a warp execute together on a SIMD-like core, and can share data through each other&#39;s registers. At the block level, threads are allocated on the same core but don&#39;t necessarily execute together, which means they need to communicate through core local memory. Another level up, only the GPU&#39;s DRAM memory is a viable communication medium.</p> <p>The <a href="https://github.com/JuliaGPU/CUDAnative.jl/blob/0721783db9ac4cc2c2948cbf8cbff4aa5f7c4271/examples/reduce/reduce.jl">Julia version of this algorithm</a> looks pretty similar to the CUDA original: this is as intended, because CUDAnative.jl is a counterpart to CUDA C. The new version is much more generic though, specializing both on the reduction operator and value type. And just like we&#39;re used to with regular Julia code, the <code>@cuda</code> macro will just-in-time compile and dispatch to the correct specialization based on the argument types.</p> <p>So how does it perform? Turns out, pretty good&#33; The chart below compares the performance of both the CUDAnative.jl and CUDA C implementations<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup>, using BenchmarkTools.jl to <a href="https://github.com/JuliaGPU/CUDAnative.jl/blob/0721783db9ac4cc2c2948cbf8cbff4aa5f7c4271/examples/reduce/benchmark.jl">measure the execution time</a>. The small constant overhead &#40;note the logarithmic scale&#41; is due to a deficiency in argument passing, and will be fixed.</p> <p><img src="/assets/blog/2017-03-14-cudanative/performance.png" alt="Performance comparison of parallel reduction implementations." /></p> <p><table class=fndef  id="fndef:2"> <tr> <td class=fndef-backref ><a href="#fnref:2">[2]</a> <td class=fndef-content >The measurements include memory transfer time, which is why a CPU implementation was not included &#40;realistically, data would be kept on the GPU as long as possible, making it an unfair comparison&#41;. </table> We also aim to be compatible with tools from the CUDA toolkit. For example, you can <a href="/assets/blog/nvvp.png">profile Julia kernels</a> using the NVIDIA Visual Profiler, or use <code>cuda-memcheck</code> to detect out-of-bound accesses</p> <pre><code class="julia hljs">$ cuda-memcheck julia examples/oob.jl
========= CUDA-MEMCHECK
========= Invalid __global__ write of size <span class=hljs-number >4</span>
=========     at <span class=hljs-number >0x00000148</span> <span class=hljs-keyword >in</span> examples/oob.jl:<span class=hljs-number >14</span>:julia_memset_66041
=========     by thread (<span class=hljs-number >10</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>) <span class=hljs-keyword >in</span> block (<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>)
=========     Address <span class=hljs-number >0x1020b000028</span> is out of bounds</code></pre> <p> Full debug information <a href="https://github.com/JuliaGPU/CUDAnative.jl/issues/31">is not available</a> yet, so <code>cuda-gdb</code> and friends will not work very well.</p> <h2 id=try_it_out ><a href="#try_it_out" class=header-anchor >Try it out&#33;</a></h2> <p>If you have experience with GPUs or CUDA development, or maintain a package which could benefit from GPU acceleration, please have a look or try out CUDAnative.jl&#33; We need all the feedback we can get, in order to prioritize development and finalize the infrastructure before Julia hits 1.0.</p> <h3 id=i_want_to_help ><a href="#i_want_to_help" class=header-anchor >I want to help</a></h3> <p>Even better&#33; There&#39;s many ways to contribute, for example by looking at the issues trackers of the individual packages making up this support:</p> <ul> <li><p><a href="https://github.com/JuliaGPU/CUDAnative.jl/issues">CUDAnative.jl</a></p> <li><p><a href="https://github.com/JuliaGPU/CUDAdrv.jl/issues">CUDAdrv.jl</a></p> <li><p><a href="https://github.com/maleadt/LLVM.jl/issues">LLVM.jl</a></p> </ul> <p>Each of those packages are also in perpetual need of better API coverage, and documentation to cover and explain what has already been implemented.</p> <h2 id=thanks ><a href="#thanks" class=header-anchor >Thanks</a></h2> <p>This work would not have been possible without Viral Shah and Alan Edelman arranging my stay at MIT. I&#39;d like to thank everybody at Julia Central and around, it has been a blast&#33; I&#39;m also grateful to Bjorn De Sutter, and IWT Vlaanderen, for supporting my time at Ghent University.</p> <table class=fndef  id="fndef:1"> <tr> <td class=fndef-backref ><a href="#fnref:1">[1]</a> <td class=fndef-content >See the <a href="https://github.com/JuliaGPU/CUDAnative.jl/blob/5f6f53c58c909d00719191fbaf5a3a88cbea4ac9/test/perf/launch_overhead/README.md">README</a> for a note on how expensive this currently is. </table> </div><br><br> <footer class="container-fluid footer-copy"> <div class=container > <div class="row footrow"> <ul> <li><a href="/project">关于我们</a> <li><a href="/about/help">寻求帮助</a> <li><a href="https://julialang.org/community/organizations/">特定领域的 Github 组织</a> <li><a href="/blog/2019/02/julia-entities/">管理者</a> <li><a href="/research/#publications">出版物</a> <li><a href="/research/#sponsors">Julia 语言赞助者</a> <li><a href="/research/#juliacn_sponsors">Julia 中文社区赞助者</a> </ul> <ul> <li><a href="/downloads/">下载</a> <li><a href="/downloads/">所有版本</a> <li><a href="https://github.com/JuliaLang/julia">源代码</a> <li><a href="/downloads/#current_stable_release">最新稳定版（Stable）</a> <li><a href="/downloads/#long_term_support_release">长期支持版本（LTS）</a> <li><a href="/downloads/platform/#platform_specific_instructions_for_unofficial_binaries">非官方编译版本</a> </ul> <ul> <li><a href="https://docs.juliacn.com/latest/">文档</a> <li><a href="https://docs.julialang.org/en/v1/">英文文档</a> <li><a href="/learning/getting-started/">初学者指南</a> <li><a href="https://docs.juliacn.com/latest/manual/faq/">常见问题（FAQ）</a> <li><a href="/learning/#books">书籍</a> </ul> <ul> <li><a href="/community/">社区</a> <li><a href="/community/#2019_julia_user_and_developer_survey">用户/开发者调查</a> <li><a href="/diversity/">多元化</a> <li><a href="/community/#official_channels">官方频道</a> <li><a href="/community/standards/">行为准则（CoC）</a> <li><a href="/community/#events">活动</a> <li><a href="https://shop.spreadshirt.com/numfocus/official+julia+logo?idea=5bca3ad9f93764414a5de55f">周边商店（SpreadShirt）</a> </ul> <ul> <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">贡献指南</a> <li><a href="https://github.com/JuliaLang/julia/issues">问题追踪器</a> <li><a href="https://github.com/JuliaLang/julia/security/policy">报告安全问题</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">需要帮助的问题</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22+">适宜新手做贡献的问题</a> <li><a href="https://docs.juliacn.com/latest/devdocs/reflection/">开发者文档</a> </ul> </div> <div id=footer-bottom  class=row > <div class="col-md-10 py-2"> <p>网站基于 <a href="https://franklinjl.org">Franklin.jl</a> 构建 —— 用于构建网站的纯 Julia 包。感谢 <a href="https://www.fastly.com">Fastly</a> 和 <a href="https://swarma.org/">集智俱乐部</a> 慷慨的基础设施支持。</p> <p>©2020 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">英文贡献者</a>、<a href="https://github.com/JuliaCN/juliacn.github.io/graphs/contributors">中文贡献者</a>。本站内容基于 <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT 协议</a> 分发。 </div> <div class="col-md-2 py-2"> <span class=float-sm-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">赞助 JuliaLang 组织</a> </span> </div> </div> </div> </footer> <script src="/libs/jquery/jquery.min.js"></script> <script src="/libs/bootstrap/bootstrap.min.js"></script>